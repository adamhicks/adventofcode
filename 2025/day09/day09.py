from collections import namedtuple
from itertools import combinations, pairwise

test_input = """7,1
11,1
11,7
9,7
9,5
2,5
2,3
7,3
"""

Coord = namedtuple("Coord", ["x", "y"])

def parse_input(s):
    return [Coord(*map(int, p.split(","))) for p in s.splitlines()]

def size(a, b):
    return (abs(b.x - a.x)+1) * (abs(b.y - a.y)+1)

def run_part1(i):
    print(max(size(a, b) for a, b in combinations(i, 2)))

def crosses(i, j, a, b):
    min_x, min_y = min(a.x, b.x), min(a.y, b.y)
    max_x, max_y = max(a.x, b.x), max(a.y, b.y)
    if i.x == j.x:
        if j.y < i.y:
            i, j = j, i
        return min_x < i.x < max_x and i.y < max_y and j.y > min_y
    else:
        if j.x < i.x:
            i, j = j, i
        return min_y < i.y < max_y and i.x < max_x and j.x > min_x

def all_edges(nodes):
    yield from pairwise(nodes)
    yield nodes[-1], nodes[0]

def empty(nodes, a, b):
    return not any(
        crosses(i, j, a, b) 
        for i, j in all_edges(nodes)
        if i != a and i != b and j != a and j != b
    )

def run_part2(i):
    print(max(size(a, b) for a, b in combinations(i, 2) if empty(i, a, b)))

### Generated by start script

def test_part1():
    run_part1(parse_input(test_input))

def part1():
    run_part1(parse_input(open("input.txt").read()))

def test_part2():
    run_part2(parse_input(test_input))

def part2():
    run_part2(parse_input(open("input.txt").read()))

def main():
    print("=== running part 1 test ===")
    test_part1()
    print("=== running part 1 ===")
    part1()
    print("=== running part 2 test ===")
    test_part2()
    print("=== running part 2 ===")
    part2()
    print("=== ===")

if __name__ == "__main__":
    main()
