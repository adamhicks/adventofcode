from collections import namedtuple
from functools import reduce
import numpy as np
from scipy.optimize import milp, LinearConstraint, Bounds


test_input = """[.##.] (3) (1,3) (2) (2,3) (0,2) (0,1) {3,5,4,7}
[...#.] (0,2,3,4) (2,3) (0,4) (0,1,2) (1,2,3,4) {7,5,12,7,2}
[.###.#] (0,1,2,3,4) (0,3,4) (0,1,2,4,5) (1,2) {10,11,11,5,10,5}
"""

Machine = namedtuple("Machine", ["target", "buttons", "joltages"])

def num_from_bool_iter(blist):
    return reduce(lambda x, y: x * 2 + (1 if y else 0), reversed(list(blist)), 0)

def num_from_bool_set(set_bits):
    return reduce(lambda x, y: x | 1 << y, set_bits, 0)

def machine_from_line(l):
    parts = l.split(" ")
    return Machine(
        target=parts[0].strip("[]"),
        buttons=[tuple(map(int, p.strip("()").split(","))) for p in parts[1:-1]],
        joltages=tuple(map(int, parts[-1].strip("{}").split(","))),
    )

def parse_input(s):
    return list(map(machine_from_line, s.splitlines()))

def bfs_flags(machine):
    mem = {0: 0}
    target = num_from_bool_iter(c == "#" for c in machine.target)
    butts = [num_from_bool_set(b) for b in machine.buttons]
    while target not in mem:
        next_mem = dict()
        for s, p in mem.items():
            for b in butts:
                ns = s ^ b
                if ns in next_mem:
                    next_mem[ns] = min(next_mem[ns], p + 1)
                else:
                    next_mem[ns] = p + 1
        mem = next_mem
    return mem[target]

def run_part1(i):
    print(sum(bfs_flags(m) for m in i))

def solve_joltages(buttons, joltage):
    n_buttons = len(buttons)
    n_outputs = len(joltage)
    
    # Build matrix A: A[j][i] = 1 if button i affects output j
    A = np.zeros((n_outputs, n_buttons))
    for i, button in enumerate(buttons):
        for idx in button:
            if idx < n_outputs:
                A[idx, i] = 1
    
    b = np.array(joltage)
    
    # Minimize sum(x) subject to Ax = b, x >= 0, x integer
    c = np.ones(n_buttons)  # minimize sum of x
    constraints = LinearConstraint(A, b, b)  # Ax = b
    bounds = Bounds(lb=0, ub=np.inf)
    integrality = np.ones(n_buttons)
    
    result = milp(c, constraints=constraints, bounds=bounds, integrality=integrality)
    
    if not result.success:
        raise ValueError(f"No solution found")
    
    return int(round(result.fun))

def run_part2(i):
    print(sum(solve_joltages(m.buttons, m.joltages) for m in i))

### Generated by start script

def test_part1():
    run_part1(parse_input(test_input))

def part1():
    run_part1(parse_input(open("input.txt").read()))

def test_part2():
    run_part2(parse_input(test_input))

def part2():
    run_part2(parse_input(open("input.txt").read()))

def main():
    print("=== running part 1 test ===")
    test_part1()
    print("=== running part 1 ===")
    part1()
    print("=== running part 2 test ===")
    test_part2()
    print("=== running part 2 ===")
    part2()
    print("=== ===")

if __name__ == "__main__":
    main()
