from collections import namedtuple

test_input = """..@@.@@@@.
@@@.@.@.@@
@@@@@.@.@@
@.@@@@..@.
@@.@@@@.@@
.@@@@@@@.@
.@.@.@.@@@
@.@@@.@@@@
.@@@@@@@@.
@.@.@@@.@.
"""

Coord = namedtuple("Coord", ["x", "y"])

def parse_input(s):
    return [[c for c in l] for l in s.splitlines()]

def neighbours(p):
    return [Coord(p.x + dx, p.y + dy) for dx in (-1, 0, 1) for dy in (-1, 0, 1) if not (dx == 0 and dy == 0)]

def get(p, grid):
    if 0 <= p.x < len(grid[0]) and 0 <= p.y < len(grid):
        return grid[p.y][p.x]
    return '.'

def removable(i):
    ret = []
    for x, row in enumerate(i):
        for y, c in enumerate(row):
            p = Coord(x, y)
            if get(p, i) != '@':
                continue
            nn = sum(1 for nc in neighbours(p) if get(nc, i) == '@')
            if nn < 4:
                ret.append(p)
    return ret

def run_part1(i):
    print(len(removable(i)))

def run_part2(i):
    count = 0
    while True:
        togo = removable(i)
        if not togo:
            break
        count += len(togo)
        for p in togo:
            i[p.y][p.x] = '.'
    print(count)

### Generated by start script

def test_part1():
    run_part1(parse_input(test_input))

def part1():
    run_part1(parse_input(open("input.txt").read()))

def test_part2():
    run_part2(parse_input(test_input))

def part2():
    run_part2(parse_input(open("input.txt").read()))

def main():
    print("=== running part 1 test ===")
    test_part1()
    print("=== running part 1 ===")
    part1()
    print("=== running part 2 test ===")
    test_part2()
    print("=== running part 2 ===")
    part2()
    print("=== ===")

if __name__ == "__main__":
    main()
