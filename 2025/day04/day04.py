from collections import namedtuple

test_input = """..@@.@@@@.
@@@.@.@.@@
@@@@@.@.@@
@.@@@@..@.
@@.@@@@.@@
.@@@@@@@.@
.@.@.@.@@@
@.@@@.@@@@
.@@@@@@@@.
@.@.@@@.@.
"""

Coord = namedtuple("Coord", ["x", "y"])

def parse_input(s):
    return [[c for c in l] for l in s.splitlines()]

def neighbours(p):
    for dx in (-1, 0, 1):
        for dy in (-1, 0, 1):
            np = Coord(p.x + dx, p.y + dy)
            if p != np:
                yield np

def get(p, grid):
    if 0 <= p.x < len(grid[0]) and 0 <= p.y < len(grid):
        return grid[p.y][p.x]
    return '.'


def run_part1(i):
    count = 0
    for x, row in enumerate(i):
        for y, c in enumerate(row):
            p = Coord(x, y)
            if get(p, i) != '@':
                continue
            nn = sum(1 for nc in neighbours(p) if get(nc, i) == '@')
            if nn < 4:
                count += 1
    print(count)

def remove_rolls(i):
    count = 0
    for x, row in enumerate(i):
        for y, c in enumerate(row):
            p = Coord(x, y)
            if get(p, i) != '@':
                continue
            nn = sum(1 for nc in neighbours(p) if get(nc, i) == '@')
            if nn < 4:
                i[p.y][p.x] = '.'
                count += 1
    return count

def run_part2(i):
    count = 0
    while True:
        c = remove_rolls(i)
        if c == 0:
            break
        count += c
    print(count)

### Generated by start script

def test_part1():
    run_part1(parse_input(test_input))

def part1():
    run_part1(parse_input(open("input.txt").read()))

def test_part2():
    run_part2(parse_input(test_input))

def part2():
    run_part2(parse_input(open("input.txt").read()))

def main():
    print("=== running part 1 test ===")
    test_part1()
    print("=== running part 1 ===")
    part1()
    print("=== running part 2 test ===")
    test_part2()
    print("=== running part 2 ===")
    part2()
    print("=== ===")

if __name__ == "__main__":
    main()
