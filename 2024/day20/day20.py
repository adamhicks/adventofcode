from collections import namedtuple, defaultdict
from functools import reduce

test_input = """###############
#...#...#.....#
#.#.#.#.#.###.#
#S#...#.#.#...#
#######.#.#.###
#######.#.#...#
#######.#.###.#
###..E#...#...#
###.#######.###
#...###...#...#
#.#####.#.###.#
#.#...#.#.#...#
#.#.#.#.#.#.###
#...#...#...###
###############
"""

Point = namedtuple("Point", ["x", "y"])

North = Point(0, -1)
South = Point(0, 1)
East = Point(1, 0)
West = Point(-1, 0)

Dirs = (North, East, South, West)

def add(a, b):
    return Point(a.x + b.x, a.y + b.y)

def neighbours(p):
    return (add(p, d) for d in Dirs)

def parse_input(s):
    return {Point(x, y): c for y, row in enumerate(s.splitlines()) for x, c in enumerate(row)}

def find(grid, t):
    return next(p for p, c in grid.items() if c == t)

def run_part1(i):
    path = {p: i for i, p in enumerate(find_path(i))}
    saves = defaultdict(int)
    for p in path:
        for end, count in find_cheats(p, i, 2):
            save = path[end] - path[p] - count
            k = key(p, end)
            saves[k] = max(saves[k], save)

    print(sum(1 for s in saves.values() if s >= 100))

def find_path(i):
    start, end = find(i, "S"), find(i, "E")
    paths = [(start,)]
    while paths:
        path = paths.pop()
        if path[-1] == end:
            return path
        for n in neighbours(path[-1]):
            if n in path or i.get(n, "#") == "#":
                continue
            paths.append(path + (n,))
    return None

def key(a, b):
    if b < a:
        return b, a
    return a, b

def run_part2(i):
    path = {p: i for i, p in enumerate(find_path(i))}
    saves = defaultdict(int)
    for p in path:
        for end, count in find_cheats(p, i, 20):
            if end not in path:
                continue
            save = path[end] - path[p] - count
            k = key(p, end)
            saves[k] = max(saves[k], save)

    print(sum(1 for s in saves.values() if s >= 100))

def find_cheats(p, i, allowed):
    reach = [p]
    done = set()
    for c in range(1, allowed+1):
        if not reach:
            break
        nr = []
        for b in reach:
            for n in neighbours(b):
                if n in done:
                    continue
                done.add(n)
                nr.append(n)
                if i.get(n, "#") != "#":
                    yield n, c
        reach = nr

### Generated by start script

def test_part1():
    run_part1(parse_input(test_input))

def part1():
    run_part1(parse_input(open("input.txt").read()))

def test_part2():
    run_part2(parse_input(test_input))

def part2():
    run_part2(parse_input(open("input.txt").read()))

def main():
    print("=== running part 1 test ===")
    test_part1()
    print("=== running part 1 ===")
    part1()
    print("=== running part 2 test ===")
    test_part2()
    print("=== running part 2 ===")
    part2()
    print("=== ===")

if __name__ == "__main__":
    main()
