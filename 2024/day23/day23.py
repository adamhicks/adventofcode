from collections import defaultdict
from itertools import chain

test_input = """kh-tc
qp-kh
de-cg
ka-co
yn-aq
qp-ub
cg-tb
vc-aq
tb-ka
wh-tc
yn-cg
kh-ub
ta-co
de-co
tc-td
tb-wq
wh-td
ta-ka
td-qp
aq-cg
wq-ub
ub-vc
de-ta
wq-aq
wq-vc
wh-yn
ka-de
kh-ta
co-tc
wh-qp
tb-vc
td-yn
"""

def parse_input(s):
    return [l.split("-") for l in s.splitlines()]

def deepen(groups, links):
    ret = set()
    for g in groups:
        for n in set.intersection(*(links[m] for m in g)):
            if n in g:
                continue
            ret.add(frozenset(chain(iter(g), (n,))))
    return ret

def get_links(i):
    links = defaultdict(set)
    for a, b in i:
        links[a].add(b)
        links[b].add(a)
    return links


def run_part1(i):
    links = get_links(i)
    groups = ({k} for k in links)
    for _ in range(2):
        groups = deepen(groups, links)

    s = sum(1 for g in groups if any(True for m in g if m[0] == "t"))
    print(s)

def run_part2(i):
    links = get_links(i)
    groups = ({k} for k in links)
    while True:
        ng = deepen(groups, links)
        if not ng:
            break
        groups = ng
    if len(groups) != 1:
        raise Exception("invalid groups", groups)
    print(",".join(sorted(groups.pop())))

### Generated by start script

def test_part1():
    run_part1(parse_input(test_input))

def part1():
    run_part1(parse_input(open("input.txt").read()))

def test_part2():
    run_part2(parse_input(test_input))

def part2():
    run_part2(parse_input(open("input.txt").read()))

def main():
    print("=== running part 1 test ===")
    test_part1()
    print("=== running part 1 ===")
    part1()
    print("=== running part 2 test ===")
    test_part2()
    print("=== running part 2 ===")
    part2()
    print("=== ===")

if __name__ == "__main__":
    main()
