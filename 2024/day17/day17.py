from itertools import batched

test_input = """Register A: 729
Register B: 0
Register C: 0

Program: 0,1,5,4,3,0
"""

def parse_input(s):
    reg, prog = s.split("\n\n")
    r = tuple(int(l.split(" ")[2]) for l in reg.splitlines())
    p = tuple(map(int, prog.split(" ")[1].split(",")))
    return r, p

def get_val(combo, reg):
    match combo:
        case 0:
            return combo
        case 1:
            return combo
        case 2:
            return combo
        case 3:
            return combo
        case 4:
            return reg[0]
        case 5:
            return reg[1]
        case 6:
            return reg[2]
        case 7:
            raise ValueError("7 called!")
        case _:
            raise ValueError("weird", combo)

def run_part1(i):
    r, p = i
    out = run_prog([v for v in r], p)
    print(",".join(str(v) for v in out))

def run_prog(reg, p):
    ins = 0
    out = []
    while ins < len(p):
        op, operand = p[ins], p[ins+1]
        match op:
            case 0:
                reg[0] = reg[0] // (2**get_val(operand, reg))
            case 1:
                reg[1] = reg[1] ^ operand
            case 2:
                reg[1] = get_val(operand, reg) % 8
            case 3:
                if reg[0] != 0:
                    ins = operand
                    continue
            case 4:
                reg[1] = reg[1] ^ reg[2]
            case 5:
                out.append(get_val(operand, reg) % 8)
            case 6:
                reg[1] = reg[0] // (2**get_val(operand, reg))
            case 7:
                reg[2] = reg[0] // (2**get_val(operand, reg))
        ins += 2
    return out

test_input2 = """Register A: 2024
Register B: 0
Register C: 0

Program: 0,3,5,4,3,0"""

def min_len(l):
    return 2 ** (3 * (l - 1))

def find_example(p, idx, bottom, top):
    i = 2
    while True:
        d = (top - bottom) // i
        for n in range(1, i):
            v = bottom + (d * n)
            out = run_prog([v, 0, 0], p)
            if out[idx:] == p[idx:]:
                return v
        i += 1

def find_range(bottom, top, upwards, p, idx):
    while (top - bottom) > 1:
        mid = bottom + ((top - bottom) // 2)
        out = run_prog([mid, 0, 0], p)
        ok = out[idx:] == p[idx:]
        if ok == upwards:
            bottom = mid
        else:
            top = mid

    out_bottom = run_prog([top, 0, 0], p)
    if out_bottom[idx:] == p[idx:]:
        return bottom
    else:
        return top

def run_part2(i):
    r, p = i
    p = list(p)

    bottom = min_len(len(p))
    top = min_len(len(p)+1)

    for idx in range(len(p)-1, -1, -1):
        n = find_example(p, idx, bottom, top)
        nb = find_range(bottom, n, False, p, idx)
        nt = find_range(n, top, True, p, idx) + 1

        bottom = nb
        top = nt
        if top - bottom < 1000:
            break

    for v in range(bottom, top):
        out = run_prog([v, 0, 0], p)
        if out == p:
            print(v)
            break

### Generated by start script

def test_part1():
    run_part1(parse_input(test_input))

def part1():
    run_part1(parse_input(open("input.txt").read()))

def test_part2():
    run_part2(parse_input(test_input2))

def part2():
    run_part2(parse_input(open("input.txt").read()))

def main():
    print("=== running part 1 test ===")
    test_part1()
    print("=== running part 1 ===")
    part1()
    print("=== running part 2 test ===")
    test_part2()
    print("=== running part 2 ===")
    part2()
    print("=== ===")

if __name__ == "__main__":
    main()
